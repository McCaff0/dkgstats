
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DKGStats.io</title>
  <meta name="description" content="Real-time statistics on the OriginTrail Decentralised Knowledge Graph.">
  <meta name="keywords" content="OriginTrail, Decentralised Knowledge Graph, DKG, TRAC, DKG analytics, DKG Stats, staking APY, TRAC price, knowledge assets, base, gnosis, neuroweb, crypto, OT, blockchain">
  <meta name="author" content="McCaff">
  <meta name="robots" content="index, follow">
  <meta property="og:title" content="DKGStats.io">
  <meta property="og:description" content="Real-time statistics on the OriginTrail Decentralised Knowledge Graph.">
  <meta property="og:image" content="https://dkgstats.io/preview-image.jpg">
  <meta property="og:url" content="https://dkgstats.io">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="DKGStats.io">
  <meta name="twitter:description" content="Real-time statistics on the OriginTrail Decentralised Knowledge Graph.">
  <meta name="twitter:image" content="https://dkgstats.io/preview-image.jpg">

  <link href="https://fonts.googleapis.com/css2?family=Play&display=swap" rel="stylesheet">
  <link rel="icon" type="image/png" href="/assets/favicons/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/assets/favicons/favicon.svg" />
  <link rel="shortcut icon" href="/assets/favicons/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-title" content="DKGStats.io" />
  <link rel="manifest" href="/assets/favicons/site.webmanifest" />
  <link rel="canonical" href="https://dkgstats.io">

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
 
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
        padding: 0;
        width: 100%;
        height: 100%;
}
      body {
        font-family: 'Play', sans-serif;
        background: #0a0a0a;
        padding: 1.25rem;
        overflow-x: hidden;
        display: flex;
        flex-direction: column;
        align-items: center;
        visibility: hidden;
}
      body.show-content {
    visibility: visible;
}
    
    h1 {
      display: none;
}

    .title-image {
      width: 25rem;
      max-width: 74%;
      display: block;
      margin: -1.5rem auto -0.5rem auto;
}

    .main-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      width: 98vw;
      max-width: 111.75rem;
      margin: 0 auto;
}
    .sub-container {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
      min-width: 24.75rem;
      max-width: 57.625rem;
      min-height: auto;
      flex-grow: 1;
}

    .container {
      background: #3b3b3b;
      padding: 0.5rem;
      border-radius: 1rem;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: center;
      gap: 0.5rem;
      max-width: 28.5625rem;
      min-width: 24.75rem;
      flex-grow: 1;
      position: relative;
      height: 50rem;

}
    
    .container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: transparent;
      box-shadow: 0 0 6.25rem rgb(78 78 78 / 40%);
      border-radius: 1rem;
      z-index: -1;
}
    
    .box {
      background: #0f0f0f;
      padding: 0.5rem;
      border-radius: 0.5rem;
      min-width: 23.75rem;
      max-width: 27.5625rem;
      width: 100%;
}
      
    .box h3 {
      text-align: center;
      font-size: 1.25rem;
      font-weight: bold;
      text-transform: uppercase;
      margin-bottom: 0;
      color: #bababa;
}
      
    .box p {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1.2rem;
      font-weight: bold;
      margin: 0.025rem 0;
      color: #bababa;
}
    .box:nth-of-type(1) {
      height: 36.8rem;
}

    .box:nth-of-type(2) {
      height:11.7rem;
}

    .half-line {
      display: block;
      height: 0.875rem
}
    .pie-space {
      display: block;
      height: 6.5rem
}
       
    .value-container {
      position: relative;
      width: 10rem;
      height: 2.5rem;
}
      
    .number-value {
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      text-align: right;
      width: 100%;
}
      
    .percentage-change {
      position: absolute;
      right: 0;
      top: 96%;
      transform: translateY(-54%);
      text-align: right;
      font-size: 0.96rem;
      width: 100%;
}
      
      .positive { color: #1c941c; }
      .negative { color: #c91e1e; }
      .neutral  { color: #a6a6a6; }

      .container.new {
        position: relative;
        
}
      .container.new::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        box-shadow: 0 0 6.25rem rgb(78 78 78 / 40%);
        z-index: -1;
}

    .graph-box {
        background: #0f0f0f;
        border-radius: 0.5rem;
        min-width: 23.75rem;
        max-width: 27.5625rem;
        width: 100%;
        height: 16rem; 
        position: relative; 
        align-items: center;
        justify-content: center;
}

    .graph-box canvas {
        position: absolute; 
        top: 0;
        left: 0;
        width: 100% !important;
        height: 100% !important;
        max-width: 100%;
        max-height: 100%;
        pointer-events: none; 
}

      .graph-box h3 {
        font-family: 'Play', sans-serif;
        font-size: 1.04rem;
        font-weight: bold;
        text-align: center;
        margin-top: 0.25rem;
        margin-bottom: -0.3125rem;
        color: #bababa;
}

.time-range-buttons {
  position: absolute;
  top: 0.285rem;
  right: 0.285rem;
  display: flex;
  border-radius: 0.25rem;
  overflow: hidden;
  background-color: #282828;
}

.time-range-button {
  border: none;
  width: 2.25rem;
  background-color: transparent;
  color: #585858;
  cursor: pointer;
  font-size: 0.875rem;
  font-family: 'Play', sans-serif;
  font-weight: bold;
  transition: background-color 0.3s, color 0.3s;
  height: 1.3rem;
  line-height: 0.75rem;
  -webkit-tap-highlight-color: #373737;
}

.time-range-button.active {
  background-color: #373737;
  color: #999999;
}
    
.time-range-button:hover {
  background-color: #373737;
}
    
.time-range-button:first-child {
  border-top-left-radius: 0.25rem;
  border-bottom-left-radius: 0.25rem;
}

.time-range-button:last-child {
  border-top-right-radius: 0.25rem;
  border-bottom-right-radius: 0.25rem;
}
      .box.new {
        height: 10.6rem;
}
    
      .epoch-box {
          background: #0f0f0f;
          border-radius: 0.5rem;
          min-width: 23.75rem;
          max-width: 27.5625rem;
          width: 100%;
          height: 16rem;
          position: relative;
          align-items: center;
          justify-content: center;
          padding: 0rem;
}
    
      .epoch-box canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100% !important;
          height: 6.5rem !important;
          max-width: 100%;
          max-height: 6.5rem;
          pointer-events: none;
}
    #customLegendContainer,
    #customRewardsLegendContainer,
    #customStakedLegendContainer {
        position: absolute;
        right: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0;
        font-family: "Play", sans-serif;
        font-size: 1rem;
        color: #bababa;
        z-index: 10;
        width: 59.3%;
}
    
    #customLegendContainer {
        top: 4.4rem;
}
    
    #customRewardsLegendContainer {
        top: 12.5rem;
}
    
    #customStakedLegendContainer {
        top: 20.65rem;
}
  
    #publishesPieChart {
    margin-top: 2.7rem;
      left: -33%;
}
    
    #rewardsPieChart {
        margin-top: 10.8rem;
        left: -33%;
}
    
    #stakedPieChart {
        margin-top: 18.9rem;
        left: -33%;
}
    .epoch-box h2 {
      text-align: center;
      font-size: 1.25rem;
      font-weight: bold;
      text-transform: uppercase;
      margin-bottom: 0;
      color: #bababa;
      margin-top: 0.5rem
}
    .epoch-box h3 {
        font-family: 'Play', sans-serif;
        font-size: 1.04rem;
        font-weight: bold;
        text-align: left;
        margin-top: 0.7rem;
        margin-bottom: -0.3125rem;
        margin-left: 32%;
        color: #bababa;
}

    .epoch-box:nth-of-type(2) {
        height: 26.7rem;
}
  
    .epoch-box:nth-of-type(3) {
        height: 10.7rem;
}
    .date-value {
   position: absolute;
        right: 0;
        top: 96%;
        transform: translateY(-50%);
        text-align: right;
        font-size: 1rem;
        width: 100%;
      color: #656666;
}
</style>
  <!-- Google Analytics Tag -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-16V8B7YWR9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-16V8B7YWR9');
  </script>
  
</head>
<body>
  <div class="scale-wrapper">
<img src="https://raw.githubusercontent.com/McCaff0/dkgstats/main/title-image.png" alt="DKGStats.io" class="title-image">
<h1>DKGStats.io - Real-Time OriginTrail DKG Statistics</h1>
<div class="main-container">
  <div class="sub-container">
    <div class="container">
      <div class="box">
        <h3>Current</h3>
        <p>
          <span>TRAC Price</span>
          <span class="value-container">
            <span id="tracprice" class="number-value">Loading...</span>
            <span id="pricechange1d" class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Market Cap</span>
          <span class="value-container">
            <span id="marketcap" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Volume</span>
          <span class="value-container">
            <span id="volume" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>P/R Ratio</span>
          <span class="value-container">
            <span id="peratio" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <span class="half-line"></span>
        <p>
          <span>TRAC Staked</span>
          <span class="value-container">
            <span id="tracstaked" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Staking APY</span>
          <span class="value-container">
            <span id="stakingapy" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <h3>30 Day Averages</h3>
        <p>
          <span>Annual Spend (USD)</span>
          <span class="value-container">
            <span id="annualspend" class="number-value">Loading...</span>
            <span id="annualspendchange1d" class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Daily Spend (TRAC)</span>
          <span class="value-container">
            <span id="dailyspend" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Daily Publishes</span>
          <span class="value-container">
            <span id="dailypublishes" class="number-value">Loading...</span>
            <span id="dailypublisheschange1d" class="percentage-change"></span>
          </span>
        </p>
        <span class="half-line"></span>
        <p>
          <span>Spend / Publish (TRAC)</span>
          <span class="value-container">
            <span id="publishpricetrac" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Spend / Publish (USD)</span>
          <span class="value-container">
            <span id="publishpriceusd" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Operator Fee</span>
          <span class="value-container">
            <span id="stakingfee" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
      </div>
      <div class="box">
        <p>
          <span>Total KA'S</span>
          <span class="value-container">
            <span id="totalkas" class="number-value">Loading...</span>
            <span id="kas24h" class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Total TRAC Spent</span>
          <span class="value-container">
            <span id="totaltracspent" class="number-value">Loading...</span>
            <span id="spend24h" class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Active Nodes</span>
          <span class="value-container">
            <span id="activenodes" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
        <p>
          <span>Paranets</span>
          <span class="value-container">
            <span id="paranets" class="number-value">Loading...</span>
            <span class="percentage-change"></span>
          </span>
        </p>
      </div>
    </div>
    <div class="container new">
  <div class="graph-box">
    <h3>TRAC Price</h3>
    <canvas id="PriceChart"></canvas>
    <div class="time-range-buttons">
      <button class="time-range-button active" data-chart-id="PriceChart" data-time-range="90D">90D</button>
      <button class="time-range-button" data-chart-id="PriceChart" data-time-range="1Y">1Y</button>
    </div>
  </div>
  <div class="graph-box">
    <h3>Daily USD Spend</h3>
    <canvas id="SpendChart"></canvas>
    <div class="time-range-buttons">
      <button class="time-range-button active" data-chart-id="SpendChart" data-time-range="90D">90D</button>
      <button class="time-range-button" data-chart-id="SpendChart" data-time-range="1Y">1Y</button>
    </div>
  </div>
  <div class="graph-box">
    <h3>Daily Publishes</h3>
    <canvas id="PublishesChart"></canvas>
    <div class="time-range-buttons">
      <button class="time-range-button active" data-chart-id="PublishesChart" data-time-range="90D">90D</button>
      <button class="time-range-button" data-chart-id="PublishesChart" data-time-range="1Y">1Y</button>
    </div>
  </div>
</div>
</div>
  <div class="sub-container">
<div class="container new">
  <div class="box new">
    <h3>RECORDS</h3>
    <p>
      <span>Daily Publishes</span>
      <span class="value-container">
        <span id="publishRecordValue" class="number-value">Loading...</span>
        <span id="publishRecordDate" class="date-value"></span>
      </span>
    </p>
    <p>
      <span>Daily Spend (TRAC)</span>
      <span class="value-container">
        <span id="tracSpendRecordValue" class="number-value">Loading...</span>
        <span id="tracSpendRecordDate" class="date-value"></span>
      </span>
    </p>
    <p>
      <span>Daily Spend (USD)</span>
      <span class="value-container">
        <span id="usdSpendRecordValue" class="number-value">Loading...</span>
        <span id="usdSpendRecordDate" class="date-value"></span>
      </span>
    </p>
  </div>
  <div class="epoch-box">
    <h2>CURRENT EPOCH</h2>
    <h3>Estimated Publishes</h3>
    <canvas id="publishesPieChart"></canvas>
    <div id="customLegendContainer"></div>
    <span class="pie-space"></span>
    <h3>Estimated Rewards</h3>
    <canvas id="rewardsPieChart"></canvas>
    <div id="customRewardsLegendContainer"></div>
    <span class="pie-space"></span>
    <h3>Staked (Active Nodes)</h3>
    <canvas id="stakedPieChart"></canvas>
    <div id="customStakedLegendContainer"></div>
    <span class="pie-space"></span>
  </div>
  <div class="epoch-box">
</div>
</div>
    <div class="container new">
      <div class="graph-box"></div>
      <div class="graph-box"></div>
      <div class="graph-box"></div>
    </div>
  </div>
</div>

  <script>
let priceLabels = [], priceValues = [];
let spendLabels = [], spendValues = [];
let publishesLabels = [], publishesValues = [];

let isFirstLoadPublishes = true, isFirstLoadRewards = true, isFirstLoadStaked = true;
let isFirstDataLoad = false, isFirstSpendLoad = false, isFirstPublishesLoad = false;

let tickFontSize, labelFontSize, chartPadding;
let pieChartBorderWidth;

function formatNumber(value, decimals = 0, isCurrency = false) {
    if (value == null || value === '') return 'Loading...';
    const number = Number(value);
    if (isNaN(number)) return value;
    const [integer, decimal] = number.toFixed(decimals).split('.');
    const formattedInteger = integer.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    return decimal ? `${formattedInteger}.${decimal}` : formattedInteger;
}

function formatPercentage(value, period) {
    if (value == null || value === '') return ' ';
    const number = Number(value);
    if (isNaN(number)) return value;
    const sign = number > 0 ? '+' : number < 0 ? '-' : '';
    const className = number > 0 ? 'positive' : number < 0 ? 'negative' : 'neutral';
    const p = Math.abs(number);
    const formatted = p < 10 ? p.toFixed(2) : p < 100 ? p.toFixed(1) : p.toFixed(0);
    return `<span class="${className}">${sign}${formatted}% (${period})</span>`;
}

function formatNumberChange(value, label = '') {
    if (value == null || value === '') return ' ';
    const number = Number(value);
    if (isNaN(number)) return value;
    const sign = number > 0 ? '+' : number < 0 ? '-' : '';
    const className = number > 0 ? 'positive' : number < 0 ? 'negative' : 'neutral';
    const [integer, decimal] = Math.abs(number).toFixed(0).split('.');
    const formattedInteger = integer.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    const formattedNumber = decimal ? `${formattedInteger}.${decimal}` : formattedInteger;
    return `<span class="${className}">${sign}${formattedNumber}</span>` + 
           (label ? ` <span class="${className}">${label}</span>` : '');
}

function formatDate(isoDate) {
    if (!isoDate) return 'N/A';
    const date = new Date(isoDate);
    if (isNaN(date.getTime())) return 'N/A';
    return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: '2-digit' });
}

function formatValueInMillions(value) {
    if (typeof value !== "number" || isNaN(value)) return "0";
    if (value >= 1000000) return `${(value / 1000000).toFixed(1)}M`;
    if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;
    return Math.round(value).toString();
}

function fetchData() {
    const SHEETDATA_URL = 'https://dkgstats-b5839-default-rtdb.firebaseio.com/data/sheetData.json';
    const RECORDS_URL = 'https://dkgstats-b5839-default-rtdb.firebaseio.com/data/records.json';

    return Promise.all([
        fetch(SHEETDATA_URL).then(r => r.json()),
        fetch(RECORDS_URL).then(r => r.json())
    ])
    .then(([sheetData, records]) => {
        console.log("Fetched Data:", {sheetData, records});
        if (sheetData) {
            handleData(sheetData, records);
        } else {
            console.error("Error: sheetData not found");
        }
        return {sheetData, records};
    })
    .catch(error => {
        console.error('Error fetching data:', error);
        throw error;
    });
}
    
function handleData(sheetData, records) {
    if (!sheetData || !records) {
        console.error("Missing required data:", { sheetData, records });
        return;
    }

    const updateText = (id, value) => {
        const element = document.getElementById(id);
        if (element) element.innerText = value;
        else console.warn(`Element #${id} not found in DOM.`);
    };

    const updateHTML = (id, value) => {
        const element = document.getElementById(id);
        if (element) element.innerHTML = value;
        else console.warn(`Element #${id} not found in DOM.`);
    };

    updateText('tracprice', formatNumber(sheetData.tracprice, 4));
    const marketCap = sheetData.tracprice * 500000000;
    updateText('marketcap', formatNumber(marketCap, 0, true));
    updateText('peratio', formatNumber(sheetData.peratio, 1));
    updateText('volume', formatNumber(sheetData.volume, 0, true));
    updateText('tracstaked', formatNumber(sheetData.tracstaked, 0, true));
    updateText('stakingapy', formatNumber(sheetData.stakingapy, 2) + '%');
    updateText('annualspend', formatNumber(sheetData.annualspend, 0, true));
    updateText('dailyspend', formatNumber(sheetData.dailyspend, 0, true));
    updateText('dailypublishes', formatNumber(sheetData.dailypublishes, 0));
    updateText('publishpricetrac', formatNumber(sheetData.publishpricetrac, 6));
    updateText('publishpriceusd', formatNumber(sheetData.publishpriceusd, 6));
    updateText('stakingfee', formatNumber(sheetData.stakingfee, 2) + '%');
    updateText('totalkas', formatNumber(sheetData.totalkas, 0));
    updateText('totaltracspent', formatNumber(sheetData.totaltracspent, 0));
    updateText('activenodes', formatNumber(sheetData.activenodes, 0));
    updateText('paranets', formatNumber(sheetData.paranets, 0));

    updateHTML('pricechange1d', formatPercentage(sheetData.pricechange1d, '24H'));
    updateHTML('dailypublisheschange1d', formatPercentage(sheetData.dailypublisheschange1d, '24H'));
    updateHTML('annualspendchange1d', formatPercentage(sheetData.annualspendchange1d, '24H'));
    updateHTML('kas24h', formatNumberChange(sheetData.kas24h, '(24H)'));
    updateHTML('spend24h', formatNumberChange(sheetData.spend24h, '(24H)'));

    const updateRecordData = (record, dateId, valueId, decimals = 0, currency = false) => {
        if (!record) {
            console.warn(`Missing record data for ${dateId} and ${valueId}`);
            return;
        }
        updateText(dateId, formatDate(record.date));
        updateText(valueId, formatNumber(record.value, decimals, currency));
    };
    updateRecordData(records.publishRecord, 'publishRecordDate', 'publishRecordValue');
    updateRecordData(records.tracSpendRecord, 'tracSpendRecordDate', 'tracSpendRecordValue');
    updateRecordData(records.usdSpendRecord, 'usdSpendRecordDate', 'usdSpendRecordValue');
}
   
function renderChart({
    canvasId,
    labels = [],
    values = [],
    datasetLabel = 'Dataset',
    yAxisTitle = 'Value',
    yAxisFormatter = null,
    isFirstLoad = false
}) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.error(`${canvasId} canvas not found!`);
        return null;
    }

    if (window[`${canvasId}Instance`]) {
        try {
            window[`${canvasId}Instance`].destroy();
        } catch (e) {
            console.warn(`Error destroying previous ${canvasId} chart:`, e);
        }
    }

    canvas.width = canvas.parentElement.offsetWidth;
    canvas.height = canvas.parentElement.offsetHeight;
    const ctx = canvas.getContext('2d');

    try {
        if (!Array.isArray(labels)) {
            console.error('Labels must be an array');
            labels = [];
        }
        if (!Array.isArray(values)) {
            console.error('Values must be an array');
            values = [];
        }

           const dateLabels = [];
    const validValues = [];
    
    for (let i = 0; i < Math.min(labels.length, values.length); i++) {
        try {
            let date;
            if (labels[i] instanceof Date) {
                date = new Date(labels[i]);
            } else if (typeof labels[i] === 'string') {
                const dateStr = labels[i].includes('T') ? labels[i].split('T')[0] : labels[i];
                date = new Date(dateStr);
            } else {
                console.warn(`Invalid label type at index ${i}:`, labels[i]);
                continue;
            }

            if (isNaN(date.getTime())) {
                console.warn(`Invalid date at index ${i}:`, labels[i]);
                continue;
            }

            dateLabels.push(date);
            validValues.push(values[i]);
        } catch (e) {
            console.warn(`Error processing data point ${i}:`, e);
        }
    }

    if (dateLabels.length === 0) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        dateLabels.push(today);
        validValues.push(0);
        console.warn(`No valid dates found - using fallback with today's date`);
    }

    dateLabels.sort((a, b) => a - b);

    const tickCount = 10;
    const minDate = dateLabels[0];
    const maxDate = dateLabels[dateLabels.length - 1];
    const dateRange = maxDate - minDate;
    
    const ticks = [];
    for (let i = 0; i < tickCount; i++) {
        const date = new Date(minDate.getTime() + (dateRange * (i / (tickCount - 1))));
        ticks.push(date);
    }

        const animationSetting = isFirstLoad ? { duration: 600 } : { duration: 0 };

    const chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: dateLabels,
            datasets: [{
                label: datasetLabel,
                data: validValues,
                borderColor: 'rgba(146, 176, 174, 1)',
                backgroundColor: 'rgba(146, 176, 174, 0.1)',
                fill: true,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 5,
                borderWidth: tickFontSize / 6
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: {
                        parser: 'yyyy-MM-dd',
                        tooltipFormat: 'MMM d, yyyy',
                        unit: 'day',
                        displayFormats: {
                            day: 'MMM d'
                        }
                    },
                    min: minDate,
                    max: maxDate,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)',
                    },
                    ticks: {
                        source: 'data',
                        autoSkip: false,
                        maxRotation: 35,
                        minRotation: 35,
                        font: { 
                            size: tickFontSize, 
                            family: 'Play, sans-serif' 
                        },
                        callback: function(value) {
                            return new Date(value).toLocaleDateString('en-US', {
                                month: 'short',
                                day: 'numeric'
                            });
                        }
                    },
                    afterBuildTicks: function(scale) {
                        scale.ticks = ticks.map(date => ({
                            value: date,
                            major: false
                        }));
                        return scale.ticks;
                    }
                },
                y: {
                    grid: { 
                        color: 'rgba(255, 255, 255, 0.05)' 
                    },
                    title: {
                        display: true,
                        text: yAxisTitle,
                        font: { 
                            size: labelFontSize, 
                            family: 'Play, sans-serif' 
                        }
                    },
                    ticks: {
                        beginAtZero: false,
                        font: { 
                            size: tickFontSize, 
                            family: 'Play, sans-serif' 
                        },
                        callback: yAxisFormatter || function(value) {
                            return Number(value).toLocaleString();
                        }
                    }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return new Date(context[0].parsed.x).toLocaleDateString('en-US', {
                                month: 'long',
                                day: 'numeric',
                                year: 'numeric'
                            });
                        },
                        label: function(context) {
                            return `${datasetLabel}: ${yAxisFormatter 
                                ? yAxisFormatter(context.parsed.y) 
                                : context.parsed.y}`;
                        }
                    }
                }
            },
            layout: {
                padding: chartPadding
            },
            animation: animationSetting
            }
        });

        window[`${canvasId}Instance`] = chartInstance;
        chartInstance._destroyed = false;

        console.log(`Created ${canvasId} chart with ${dateLabels.length} data points`);
        return chartInstance;

    } catch (error) {
        console.error(`Error rendering ${canvasId} chart:`, error);
        const fallbackChart = new Chart(ctx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: { responsive: true }
        });
        window[`${canvasId}Instance`] = fallbackChart;
        return fallbackChart;
    }
}
function renderPieChart({
    canvasId,
    legendContainerId,
    data,
    chartInstance,
    isFirstLoad
}) {
    const ctx = document.getElementById(canvasId).getContext("2d");
    const total = data.reduce((sum, value) => sum + value, 0);
    const combinedData = ["Neuroweb", "Base", "Gnosis"].map((label, i) => ({
        label: label,
        value: data[i],
        percentage: (data[i] / total * 100).toFixed(1),
        color: ["#262626", "#1f62a1", "#076940"][i]
    }));

    combinedData.sort((a, b) => b.percentage - a.percentage);

    const legendContainer = document.getElementById(legendContainerId);
    if (legendContainer) {
        const canvasElement = legendContainer.previousElementSibling;
        const h3Title = canvasElement ? canvasElement.previousElementSibling : null;

        if (h3Title && h3Title.tagName === "H3") {
            const titleText = h3Title.textContent.split(" - ")[0];
            h3Title.textContent = `${titleText} - ${formatValueInMillions(total)}`;
        }

        legendContainer.innerHTML = combinedData.map(item => `
            <div style="display: flex; align-items: center; margin-bottom: 0.5rem; font-family: 'Play', sans-serif;">
                <div style="
                    width: 1.05rem; 
                    height: 1.05rem; 
                    background: ${item.color}; 
                    border: 0.15rem solid #bababa; 
                    border-radius: 50%; 
                    margin-right: 0.5rem;
                "></div>
                <span style="font-weight: bold;">${item.label} - ${formatValueInMillions(item.value)}</span>
                <span style="margin-left: auto; font-weight: bold;">${item.percentage}%</span>
            </div>
        `).join("");
    }

    if (isFirstLoad) {
        window[`${canvasId}Instance`] = new Chart(ctx, {
            type: "doughnut",
            data: {
                labels: combinedData.map(item => item.label),
                datasets: [{
                    data: combinedData.map(item => item.value),
                    backgroundColor: combinedData.map(item => item.color),
                    borderColor: "#bababa",
                    hoverOffset: 10,
                    borderWidth: pieChartBorderWidth,
                    cutout: "55%"
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                animation: {
                    duration: 600,
                }
            }
        });
        isFirstLoad = false;
    } else {
        if (window[`${canvasId}Instance`]) {
            window[`${canvasId}Instance`].data.labels = combinedData.map(item => item.label);
            window[`${canvasId}Instance`].data.datasets[0].data = combinedData.map(item => item.value);
            window[`${canvasId}Instance`].data.datasets[0].backgroundColor = combinedData.map(item => item.color);
            window[`${canvasId}Instance`].update();
        }
    }
}

function updateFontSizesAndPadding(newFontSize) {
    tickFontSize = newFontSize * 0.75;
    labelFontSize = newFontSize * 0.875;
    chartPadding = {
        left: newFontSize * 0.2,
        right: newFontSize * 1.5625,
        top: newFontSize * 1.8,
        bottom: newFontSize * 0
    };
}

function updatePieChartFontSizesAndPadding(newFontSize) {
    pieChartFontSize = newFontSize * 1.05;
    pieChartLayoutPadding = newFontSize * 1;
    pieChartBorderWidth = Math.max(1, newFontSize * 0.125);
}

function adjustFontSize() {
    return new Promise((resolve) => {
        const referenceHeight = document.documentElement.clientHeight || window.innerHeight;
        const baseFontSize = 16;
        const scalingFactor = referenceHeight / 973;
        let newFontSize = baseFontSize * scalingFactor * 1.09;

        const minScaleFactor = 0.6;
        const minFontSize = baseFontSize * (window.screen.height * minScaleFactor / 973) * 1.09;
        newFontSize = Math.max(newFontSize, minFontSize);

        const container = document.querySelector('.container');
        if (container) {
            const containerWidth = container.offsetWidth;
            const viewportWidth = window.innerWidth;
            const maxWidth = 0.96 * viewportWidth;
            if (containerWidth > maxWidth) {
                newFontSize *= maxWidth / containerWidth;
            }
        }

        document.documentElement.style.setProperty('font-size', `${newFontSize}px`);
        resolve(newFontSize);
    });
}

async function resizeCharts() {
    try {
        const newFontSize = await adjustFontSize();
        updateFontSizesAndPadding(newFontSize);
        updatePieChartFontSizesAndPadding(newFontSize);

        const lineChartInstances = [
            { name: 'PriceChartInstance', instance: window.PriceChartInstance },
            { name: 'SpendChartInstance', instance: window.SpendChartInstance },
            { name: 'PublishesChartInstance', instance: window.PublishesChartInstance }
        ];

        const pieChartInstances = [
            { name: 'publishesPieChartInstance', instance: window.publishesPieChartInstance },
            { name: 'rewardsPieChartInstance', instance: window.rewardsPieChartInstance },
            { name: 'stakedPieChartInstance', instance: window.stakedPieChartInstance }
        ];

        lineChartInstances.forEach(({ name, instance }) => {
            try {
                if (instance && !instance._destroyed && instance.options?.scales?.x) {
                    instance.options.scales.x.ticks.font.size = tickFontSize;
                    instance.options.scales.y.ticks.font.size = tickFontSize;
                    instance.options.scales.y.title.font.size = labelFontSize;
                    instance.options.layout.padding = chartPadding;
                    instance.data.datasets.forEach(dataset => {
                        dataset.borderWidth = tickFontSize / 6;
                    });
                    instance.update('none');
                }
            } catch (error) {
                console.error(`Error updating line chart ${name}:`, error);
            }
        });

        pieChartInstances.forEach(({ name, instance }) => {
            try {
                if (instance && !instance._destroyed) {
                    instance.data.datasets.forEach(dataset => {
                        dataset.borderWidth = pieChartBorderWidth;
                    });
                    instance.update('none');
                }
            } catch (error) {
                console.error(`Error updating pie chart ${name}:`, error);
            }
        });

    } catch (error) {
        console.error("Error in resizeCharts:", error);
    }
}

let isThrottled = false;
let finalCheckTimeout = null;
const throttleDelay = 100;
const finalCheckDelay = 500;

function handleResize() {

    if (finalCheckTimeout) {
        clearTimeout(finalCheckTimeout);
        finalCheckTimeout = null;
    }

    if (!isThrottled) {
        resizeCharts();
        isThrottled = true;

        setTimeout(() => {
            isThrottled = false;
        }, throttleDelay);
    }
    finalCheckTimeout = setTimeout(() => {
        if (!isThrottled) {
            resizeCharts();
        }
        finalCheckTimeout = null;
    }, finalCheckDelay);
}

const isPageLoaded = () => document.readyState === 'complete';

const chartConfigurations = {
    PriceChart: { timeRange: '90D' },
    SpendChart: { timeRange: '90D' },
    PublishesChart: { timeRange: '90D' }
};

const CHART_DATA_BASE_URL = 'https://dkgstats-b5839-default-rtdb.firebaseio.com/data/charts';
const CACHE_EXPIRY_TIME = 180000;
const LOCAL_STORAGE_KEY = 'chartCache';

let chartCache = (() => {
    try {
        const cached = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY)) || {};
        // Validate cache structure
        Object.keys(cached).forEach(key => {
            if (!cached[key]?.timestamp || 
                !cached[key]?.data || 
                !Array.isArray(cached[key].data.labels)) {
                delete cached[key];
            }
        });
        return cached;
    } catch (e) {
        console.warn('Cache parse error, initializing fresh cache', e);
        return {};
    }
})();

const MAX_CACHE_ITEMS = 10;

let cacheWritePending = false;
function updateCache(key, data) {
    chartCache[key] = {
        ...data,
        timestamp: Date.now()
    };

    const cacheKeys = Object.keys(chartCache);
    if (cacheKeys.length > MAX_CACHE_ITEMS) {
        cacheKeys.sort((a, b) => chartCache[a].timestamp - chartCache[b].timestamp);
        cacheKeys.slice(0, cacheKeys.length - MAX_CACHE_ITEMS).forEach(key => {
            console.log(`Evicting old cache entry: ${key}`);
            delete chartCache[key];
        });
    }
    
    if (!cacheWritePending) {
        cacheWritePending = true;
        setTimeout(() => {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(chartCache));
                console.debug(`Cache updated. Current items: ${Object.keys(chartCache).length}/${MAX_CACHE_ITEMS}`);
            } catch (e) {
                console.error('Cache write failed', e);
                if (e.name === 'QuotaExceededError') {
                    console.warn('Storage full, clearing cache');
                    chartCache = {};
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                }
            }
            cacheWritePending = false;
        }, 1000);
    }
}

function normalizeDate(dateStr) {
    if (!dateStr) return null;
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return dateStr;
    if (dateStr.includes('T')) return dateStr.split('T')[0];
    try {
        return new Date(dateStr).toISOString().split('T')[0];
    } catch (e) {
        console.warn('Failed to normalize date:', dateStr);
        return null;
    }
}

function isSameDate(dateStr1, dateStr2) {
    const d1 = normalizeDate(dateStr1);
    const d2 = normalizeDate(dateStr2);
    return d1 && d2 && d1 === d2;
}

async function fetchLatestValue(endpoint) {
    const url = `${CHART_DATA_BASE_URL}${endpoint.path.replace('.json', '/latest.json')}`;
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        
        return {
            date: normalizeDate(data.date),
            value: endpoint.path === '/price.json' 
                ? parseFloat(data.value.toFixed(2)) 
                : data.value
        };
    } catch (error) {
        console.error('Failed to fetch latest value:', error);
        throw error;
    }
}

async function fetchFullDataset(endpoint, cacheKey) {
    const timeRange = chartConfigurations[endpoint.chartId].timeRange;
    const url = `${CHART_DATA_BASE_URL}${endpoint.path.replace('.json', `/${timeRange}.json`)}`;
    
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();

        if (!Array.isArray(data) || data.length === 0) {
            throw new Error('Empty or invalid data received');
        }

        const processedData = data
            .map(item => ({
                date: normalizeDate(item.date),
                value: endpoint.path === '/price.json' 
                    ? parseFloat(item.value.toFixed(2)) 
                    : item.value
            }))
            .filter(item => item.date)
            .sort((a, b) => new Date(a.date) - new Date(b.date));

        if (processedData.length === 0) {
            throw new Error('No valid data points after processing');
        }

        return {
            timestamp: Date.now(),
            data: {
                labels: processedData.map(item => item.date),
                values: processedData.map(item => item.value)
            }
        };
    } catch (error) {
        console.error(`Error fetching full dataset for ${endpoint.chartId}:`, error);
        throw error;
    }
}

async function fetchChartData(chartId = null) {
    const now = Date.now();
    const today = normalizeDate(new Date().toISOString());

    const endpoints = [
        { path: '/price.json', chartId: 'PriceChart', datasetLabel: 'Price', yAxisTitle: 'Price (USD)', yAxisFormatter: null },
        { path: '/spend.json', chartId: 'SpendChart', datasetLabel: 'Spend', yAxisTitle: 'Spend (USD)', yAxisFormatter: (value) => value >= 1000 ? (value / 1000) + 'K' : value },
        { path: '/publishes.json', chartId: 'PublishesChart', datasetLabel: 'Publishes', yAxisTitle: 'Publishes', yAxisFormatter: (value) => value >= 1000000 ? (value / 1000000) + 'M' : value }
    ];

    const filteredEndpoints = chartId ? endpoints.filter(endpoint => endpoint.chartId === chartId) : endpoints;

    for (const endpoint of filteredEndpoints) {
        try {
            const timeRange = chartConfigurations[endpoint.chartId].timeRange;
            const cacheKey = `${endpoint.chartId}_${timeRange}`;
            const cachedData = chartCache[cacheKey];

            if (!cachedData) {
                console.log(`No cache found for ${cacheKey}, fetching full dataset`);
                const freshData = await fetchFullDataset(endpoint, cacheKey);
                updateCache(cacheKey, freshData);
                renderChartDataIfPageLoaded(endpoint, freshData.data);
                continue;
            }

            const lastCachedDate = cachedData.data.labels[cachedData.data.labels.length - 1];
            const isCacheFresh = (now - cachedData.timestamp) < CACHE_EXPIRY_TIME;
            const isDataCurrent = isSameDate(lastCachedDate, today);

            if (isCacheFresh && isDataCurrent) {
                console.log('Using cached data (fresh and current)');
                renderChartDataIfPageLoaded(endpoint, cachedData.data);
                continue;
            }

           if (isDataCurrent) {
    console.log('Fetching latest value (cache stale but data current)');
    try {
        const latest = await fetchLatestValue(endpoint);
        if (latest && latest.date) {
            const latestDate = new Date(latest.date);
            latestDate.setHours(12, 0, 0, 0);
            
            const lastCachedDate = new Date(cachedData.data.labels[cachedData.data.labels.length - 1]);
            lastCachedDate.setHours(12, 0, 0, 0);
            
            if (latestDate.getTime() === lastCachedDate.getTime()) {
                const updatedValues = [...cachedData.data.values];
                updatedValues[updatedValues.length - 1] = latest.value;
                
                const updatedData = {
                    timestamp: now,
                    data: {
                        labels: [...cachedData.data.labels],
                        values: updatedValues
                    }
                };
                updateCache(cacheKey, updatedData);
                renderChartDataIfPageLoaded(endpoint, updatedData.data);
            } else if (latestDate > lastCachedDate) {
                const updatedData = {
                    timestamp: now,
                    data: {
                        labels: [...cachedData.data.labels, latest.date],
                        values: [...cachedData.data.values, latest.value]
                    }
                };
                updateCache(cacheKey, updatedData);
                renderChartDataIfPageLoaded(endpoint, updatedData.data);
            } else {
                updateCache(cacheKey, { ...cachedData, timestamp: now });
                renderChartDataIfPageLoaded(endpoint, cachedData.data);
            }
        } else {
            console.warn('Invalid latest data received:', latest);
            renderChartDataIfPageLoaded(endpoint, cachedData.data);
        }
    } catch (error) {
        console.warn('Failed to fetch latest value, using existing cache', error);
        renderChartDataIfPageLoaded(endpoint, cachedData.data);
                }
                continue;
            }

            console.log('Fetching full dataset (data outdated)');
            try {
                const freshData = await fetchFullDataset(endpoint, cacheKey);
                updateCache(cacheKey, freshData);
                renderChartDataIfPageLoaded(endpoint, freshData.data);
            } catch (error) {
                console.error('Failed to fetch full dataset, using existing cache', error);
                renderChartDataIfPageLoaded(endpoint, cachedData.data);
            }

        } catch (error) {
            console.error(`Error processing ${endpoint.chartId}:`, error);
        }
    }
}

function renderChartDataIfPageLoaded(endpoint, data) {
    const render = () => {
        try {
            if (!data || !data.labels || !data.values || data.labels.length !== data.values.length) {
                console.error('Invalid data for rendering:', data);
                return;
            }

            if (window[`${endpoint.chartId}Instance`]) {
                try {
                    window[`${endpoint.chartId}Instance`].destroy();
                } catch (e) {
                    console.warn('Error destroying chart:', e);
                }
            }

            const firstLoadFlag = `${endpoint.chartId}FirstPopulatedLoadFlag`;
            if (window[firstLoadFlag] === undefined) {
                window[firstLoadFlag] = true;
            }

            const dateLabels = data.labels.map(label => new Date(label));

            window[`${endpoint.chartId}Instance`] = renderChart({
                canvasId: endpoint.chartId,
                labels: dateLabels,
                values: data.values,
                datasetLabel: endpoint.datasetLabel,
                yAxisTitle: endpoint.yAxisTitle,
                yAxisFormatter: endpoint.yAxisFormatter,
                isFirstLoad: window[firstLoadFlag]
            });

            if (window[firstLoadFlag]) {
                window[firstLoadFlag] = false;
            }

        } catch (error) {
            console.error('Error rendering chart:', error);
        }
    };

    if (isPageLoaded()) {
        requestAnimationFrame(render);
    } else {
        window.addEventListener('load', () => requestAnimationFrame(render), { once: true });
    }
}

function updateChartTimeRange(chartId, timeRange) {
    if (chartConfigurations[chartId]) {

        chartConfigurations[chartId].timeRange = timeRange;
        fetchChartData(chartId);
    }
}

window.debugChartCache = () => {
    console.group('Chart Cache Debug');
    console.log('In-memory cache:', chartCache);
    console.log('LocalStorage cache:', JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY)) || {});
    ['PriceChart', 'SpendChart', 'PublishesChart'].forEach(chartId => {
        console.log(`${chartId} instance exists:`, !!window[`${chartId}Instance`]);
    });
    console.groupEnd();
};

function clearChartCache(chartId = null) {
    if (chartId) {
        Object.keys(chartCache).forEach(key => {
            if (key.startsWith(chartId)) {
                delete chartCache[key];
            }
        });
    } else {
        chartCache = {};
    }
    localStorage.removeItem(LOCAL_STORAGE_KEY);
    console.log(chartId ? `Cleared cache for ${chartId}` : 'Cleared all chart caches');
}
function fetchPieChartData() {
    const CHART_DATA_BASE_URL = 'https://dkgstats-b5839-default-rtdb.firebaseio.com/data/chains';

    fetch(CHART_DATA_BASE_URL + '.json')
        .then(response => response.json())
        .then(data => {
            console.log("Chains Data:", data);
            if (!data) {
                console.warn("No valid chains data received.");
                return;
            }

            function renderWhenReady() {
                const chartsConfig = [
                    {
                        canvasId: 'publishesPieChart',
                        legendContainerId: 'customLegendContainer',
                        field: 'epochPublishes',
                        instanceKey: 'publishesPieChartInstance'
                    },
                    {
                        canvasId: 'rewardsPieChart',
                        legendContainerId: 'customRewardsLegendContainer',
                        field: 'epochRewards',
                        instanceKey: 'rewardsPieChartInstance'
                    },
                    {
                        canvasId: 'stakedPieChart',
                        legendContainerId: 'customStakedLegendContainer',
                        field: 'stakedAmount',
                        instanceKey: 'stakedPieChartInstance'
                    }
                ];

                chartsConfig.forEach(chart => {
                    const values = [
                        data.neuroweb?.[chart.field] || 0,
                        data.base?.[chart.field] || 0,
                        data.gnosis?.[chart.field] || 0
                    ];
                    renderPieChart({
                        canvasId: chart.canvasId,
                        legendContainerId: chart.legendContainerId,
                        data: values,
                        chartInstance: window[chart.instanceKey],
                        isFirstLoad: false
                    });
                });
            }

            if (isPageLoaded()) {
                renderWhenReady();
            } else {
                window.addEventListener('load', renderWhenReady, { once: true });
            }
        })
        .catch(error => {
            console.error("Error fetching chains data:", error);
        });
}

document.querySelectorAll('.time-range-button').forEach(button => {
  button.addEventListener('click', () => {
    const chartId = button.getAttribute('data-chart-id');
    const timeRange = button.getAttribute('data-time-range');

    button.parentElement.querySelectorAll('.time-range-button').forEach(btn => {
      btn.classList.remove('active');
    });

    button.classList.add('active');
    updateChartTimeRange(chartId, timeRange);
  });
});
    
document.addEventListener('DOMContentLoaded', function () {
    console.log('DOM fully loaded and parsed');

    if (typeof fetchData !== 'function') {
        console.error('fetchData is not a function');
        return;
    }

    let isFirstLoadPublishes = true;
    let isFirstLoadRewards = true;
    let isFirstLoadStaked = true;

    adjustFontSize();
    resizeCharts();
    console.log('Initializing empty charts...');
    window.PriceChartInstance = renderChart({
        canvasId: 'PriceChart',
        labels: [],
        values: [],
        datasetLabel: 'Price',
        yAxisTitle: 'Price (USD)',
        animate: false,
    });

    window.SpendChartInstance = renderChart({
        canvasId: 'SpendChart',
        labels: [],
        values: [],
        datasetLabel: 'Spend',
        yAxisTitle: 'Spend (USD)',
        yAxisFormatter: (value) => value >= 1000 ? (value / 1000) + 'K' : value,
        animate: false,
    });

    window.PublishesChartInstance = renderChart({
        canvasId: 'PublishesChart',
        labels: [],
        values: [],
        datasetLabel: 'Publishes',
        yAxisTitle: 'Publishes',
        yAxisFormatter: (value) => value >= 1000000 ? (value / 1000000) + 'M' : value,
        animate: false,
    });

    renderPieChart({
        canvasId: 'publishesPieChart',
        legendContainerId: 'customLegendContainer',
        data: [],
        isFirstLoad: isFirstLoadPublishes
    });

    renderPieChart({
        canvasId: 'rewardsPieChart',
        legendContainerId: 'customRewardsLegendContainer',
        data: [],
        isFirstLoad: isFirstLoadRewards
    });

    renderPieChart({
        canvasId: 'stakedPieChart',
        legendContainerId: 'customStakedLegendContainer',
        data: [],
        isFirstLoad: isFirstLoadStaked
    });
    console.log('Fetching data...');
      fetchChartData();
      fetchPieChartData();
      fetchData()
    .then(() => {
        console.log('fetchData completed successfully');
    })
    .catch((error) => {
        console.error('Error in fetchData:', error);
    });

});

window.addEventListener('load', function () {
  document.body.style.transition = 'font-size 0.1s ease';
  document.body.classList.add('show-content');
  
    setTimeout(() => {
        adjustFontSize();
        resizeCharts();
    }, 1000);
});

window.addEventListener('resize', handleResize);
    
let dataInterval, chartInterval, piechartInterval;

function startIntervals() {
    clearInterval(dataInterval);
    clearInterval(chartInterval);
    clearInterval(piechartInterval);

    dataInterval = setInterval(fetchData, 30000);
    chartInterval = setInterval(() => {
        Object.keys(chartConfigurations).forEach(chartId => {
            fetchChartData(chartId);
        });
    }, 180000);
    piechartInterval = setInterval(fetchPieChartData, 180000);
}
startIntervals();
    
  </script>
  
</body>
</html>
